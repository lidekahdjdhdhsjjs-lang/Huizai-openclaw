#!/usr/bin/env node
/**
 * 知识结晶器 - Knowledge Crystallizer
 * 将高频失败模式转化为可复用的hooks/skills/config
 * 
 * 结晶目标:
 *   - Hook: 自动处理特定错误模式
 *   - Skill: 封装常用操作流程
 *   - Config: 调整系统配置优化行为
 */

const fs = require('fs');
const path = require('path');

const OPENCLAW_DIR = process.env.OPENCLAW_DIR || path.join(process.env.HOME, '.openclaw');
const HOOKS_DIR = path.join(OPENCLAW_DIR, 'hooks');
const SKILLS_DIR = path.join(OPENCLAW_DIR, 'skills');
const PATTERNS_FILE = path.join(OPENCLAW_DIR, 'workspace', 'memory', '.unified', 'L1-structured', 'patterns', 'extracted-patterns.json');
const CRYSTALLIZED_DIR = path.join(OPENCLAW_DIR, 'workspace', 'memory', '.unified', 'L1-structured', 'crystallized');

// 确保目录存在
[CRYSTALLIZED_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
});

// ============================================
// Hook生成器
// ============================================

function generateHook(pattern) {
  const hookName = `auto-fix-${pattern.tool}-${Date.now().toString(36)}`;
  const hookDir = path.join(HOOKS_DIR, hookName);
  
  // 生成hook代码
  const hookCode = `/**
 * Auto-generated Hook: ${hookName}
 * Pattern: ${pattern.errorPattern.slice(0, 100)}
 * Occurrences: ${pattern.occurrences}
 * Generated: ${new Date().toISOString()}
 */

module.exports = {
  name: '${hookName}',
  events: ['tool_error'],
  
  handler: async (ctx) => {
    const { tool, error } = ctx;
    
    // 检查是否匹配模式
    if (tool !== '${pattern.tool}') return ctx;
    
    const errorStr = String(error).toLowerCase();
    const pattern = '${pattern.errorPattern.toLowerCase()}';
    
    if (!errorStr.includes(pattern.slice(0, 50).toLowerCase())) {
      return ctx;
    }
    
    // 自动修复策略
    console.log('[${hookName}] Detected pattern, attempting fix...');
    
    // TODO: 根据具体错误实现修复逻辑
    // 常见策略:
    // 1. 重试
    // 2. Fallback到备用方案
    // 3. 参数调整
    
    return ctx;
  }
};
`;

  // 生成HOOK.md
  const hookMd = `---
name: ${hookName}
description: 自动处理 ${pattern.tool} 工具的 ${pattern.errorPattern.slice(0, 50)} 错误
metadata:
  openclaw:
    events: ["tool_error"]
    autoGenerated: true
    patternId: ${pattern.id}
---

# ${hookName}

自动生成的错误处理Hook。

## 匹配条件
- 工具: \`${pattern.tool}\`
- 错误: ${pattern.errorPattern.slice(0, 100)}
- 出现次数: ${pattern.occurrences}

## 行为
当检测到匹配的错误时，自动尝试修复。
`;

  return {
    name: hookName,
    dir: hookDir,
    files: {
      'handler.js': hookCode,
      'HOOK.md': hookMd
    }
  };
}

// ============================================
// Skill生成器
// ============================================

function generateSkill(pattern) {
  const skillName = `auto-${pattern.tool}-handler`;
  const skillDir = path.join(SKILLS_DIR, skillName);
  
  const skillMd = `---
name: ${skillName}
description: 自动处理 ${pattern.tool} 常见问题的技能
---

# ${skillName}

基于失败模式自动生成的技能。

## 背景
- 发现 ${pattern.occurrences} 次类似失败
- 模式: ${pattern.errorPattern.slice(0, 100)}

## 能力
1. 检测 ${pattern.tool} 工具的常见错误
2. 自动尝试修复
3. 记录处理结果

## 使用场景
- ${pattern.tool} 操作失败时
- 需要重试或fallback时

## 自动化程度
- 检测: 自动
- 修复: 需要进一步配置
`;

  return {
    name: skillName,
    dir: skillDir,
    files: {
      'SKILL.md': skillMd
    }
  };
}

// ============================================
// Web Fetch Fallback 特殊处理
// ============================================

function generateWebFetchFallback() {
  // web_fetch 健康度仅61%，需要专门的fallback
  const hookName = 'web-fetch-fallback';
  const hookDir = path.join(HOOKS_DIR, hookName);
  
  const hookCode = `/**
 * Web Fetch Fallback Hook
 * 当 web_fetch 失败时，尝试备用方案
 * 
 * 策略:
 * 1. 重试 (最多3次，指数退避)
 * 2. 使用 web_search 替代
 * 3. 使用 browser 访问
 */

module.exports = {
  name: 'web-fetch-fallback',
  events: ['tool_error'],
  
  handler: async (ctx) => {
    const { tool, error, args, retry } = ctx;
    
    if (tool !== 'web_fetch') return ctx;
    
    const errorStr = String(error).toLowerCase();
    console.log('[web-fetch-fallback] Error:', errorStr.slice(0, 100));
    
    // 策略1: 重试 (带退避)
    if (!retry || retry.count < 3) {
      const delay = Math.pow(2, (retry?.count || 0)) * 1000;
      console.log('[web-fetch-fallback] Retrying in', delay, 'ms');
      await new Promise(r => setTimeout(r, delay));
      return { ...ctx, retry: { count: (retry?.count || 0) + 1, action: 'retry' } };
    }
    
    // 策略2: 使用 web_search 替代
    if (args?.url) {
      console.log('[web-fetch-fallback] Fallback to web_search');
      return { 
        ...ctx, 
        fallback: { 
          tool: 'web_search', 
          args: { query: args.url }
        }
      };
    }
    
    // 策略3: 使用 browser 访问
    console.log('[web-fetch-fallback] Fallback to browser');
    return { 
      ...ctx, 
      fallback: { 
        tool: 'browser', 
        args: { action: 'navigate', url: args?.url }
      }
    };
  }
};
`;

  const hookMd = `---
name: web-fetch-fallback
description: web_fetch失败时的自动降级处理
metadata:
  openclaw:
    events: ["tool_error"]
    priority: high
---

# Web Fetch Fallback

当 web_fetch 工具失败时，自动尝试备用方案。

## 策略
1. **重试**: 最多3次，指数退避 (1s, 2s, 4s)
2. **Web Search**: 使用搜索替代直接抓取
3. **Browser**: 使用浏览器渲染页面

## 触发条件
- 工具: \`web_fetch\`
- 错误: 任何错误

## 效果
预期将 web_fetch 健康度从 61% 提升到 85%+
`;

  return {
    name: hookName,
    dir: hookDir,
    files: {
      'handler.js': hookCode,
      'HOOK.md': hookMd
    }
  };
}

// ============================================
// Message Retry 特殊处理
// ============================================

function generateMessageRetryHook() {
  const hookName = 'message-auto-retry';
  const hookDir = path.join(HOOKS_DIR, hookName);
  
  const hookCode = `/**
 * Message Auto-Retry Hook
 * 自动重试失败的消息发送
 * 
 * 常见错误: gateway closed, unauthorized, timeout
 */

module.exports = {
  name: 'message-auto-retry',
  events: ['tool_error'],
  
  handler: async (ctx) => {
    const { tool, error } = ctx;
    
    if (tool !== 'message') return ctx;
    
    const errorStr = String(error).toLowerCase();
    
    // Gateway closed - 需要重连
    if (errorStr.includes('gateway closed') || errorStr.includes('unauthorized')) {
      console.log('[message-auto-retry] Gateway issue, may need reconnect');
      return { 
        ...ctx, 
        action: 'reconnect',
        retry: { count: 1, action: 'retry' }
      };
    }
    
    // Timeout - 直接重试
    if (errorStr.includes('timeout')) {
      console.log('[message-auto-retry] Timeout, retrying...');
      return { ...ctx, retry: { count: 1, action: 'retry' } };
    }
    
    return ctx;
  }
};
`;

  const hookMd = `---
name: message-auto-retry
description: 消息发送失败时的自动重试
metadata:
  openclaw:
    events: ["tool_error"]
---

# Message Auto-Retry

自动处理 message 工具的常见错误。

## 处理的错误
- Gateway closed / unauthorized → 重连
- Timeout → 重试
- 其他错误 → 记录日志
`;

  return {
    name: hookName,
    dir: hookDir,
    files: {
      'handler.js': hookCode,
      'HOOK.md': hookMd
    }
  };
}

// ============================================
// 主结晶函数
// ============================================

function crystallize() {
  console.log('=== 知识结晶器运行 ===\n');

  // 读取提取的模式
  if (!fs.existsSync(PATTERNS_FILE)) {
    console.log('[ERROR] 未找到 extracted-patterns.json，请先运行 pattern-extractor.js');
    process.exit(1);
  }

  const data = JSON.parse(fs.readFileSync(PATTERNS_FILE, 'utf8'));
  const results = {
    generatedAt: new Date().toISOString(),
    hooks: [],
    skills: [],
    skipped: []
  };

  // 1. 专门处理 web_fetch (健康度最低)
  console.log('1. 生成 web_fetch fallback hook...');
  const webFetchHook = generateWebFetchFallback();
  results.hooks.push(webFetchHook);
  console.log(`   生成: ${webFetchHook.name}`);

  // 2. 专门处理 message (失败次数最多)
  console.log('2. 生成 message retry hook...');
  const messageHook = generateMessageRetryHook();
  results.hooks.push(messageHook);
  console.log(`   生成: ${messageHook.name}`);

  // 3. 处理其他可结晶模式
  console.log('3. 处理其他可结晶模式...');
  const crystallizablePatterns = data.patterns?.filter(p => p.crystallizable) || [];
  
  crystallizablePatterns.slice(0, 3).forEach(pattern => {
    // 跳过已处理的
    if (pattern.tool === 'web_fetch' || pattern.tool === 'message') {
      results.skipped.push(pattern);
      return;
    }
    
    // 根据出现次数决定生成hook还是skill
    if (pattern.occurrences >= 10) {
      const hook = generateHook(pattern);
      results.hooks.push(hook);
      console.log(`   Hook: ${hook.name} (${pattern.tool})`);
    } else {
      const skill = generateSkill(pattern);
      results.skills.push(skill);
      console.log(`   Skill: ${skill.name} (${pattern.tool})`);
    }
  });

  // 4. 写入文件
  console.log('\n4. 写入结晶文件...');
  results.hooks.forEach(hook => {
    if (!fs.existsSync(hook.dir)) {
      fs.mkdirSync(hook.dir, { recursive: true });
    }
    Object.entries(hook.files).forEach(([filename, content]) => {
      fs.writeFileSync(path.join(hook.dir, filename), content);
    });
    console.log(`   ✓ ${hook.name}/`);
  });

  results.skills.forEach(skill => {
    if (!fs.existsSync(skill.dir)) {
      fs.mkdirSync(skill.dir, { recursive: true });
    }
    Object.entries(skill.files).forEach(([filename, content]) => {
      fs.writeFileSync(path.join(skill.dir, filename), content);
    });
    console.log(`   ✓ ${skill.name}/`);
  });

  // 5. 保存结晶记录
  const recordPath = path.join(CRYSTALLIZED_DIR, 'crystallization-record.json');
  fs.writeFileSync(recordPath, JSON.stringify(results, null, 2));
  console.log(`\n结晶记录: ${recordPath}`);

  // 6. 输出摘要
  console.log('\n=== 结晶完成 ===');
  console.log(`Hooks: ${results.hooks.length}`);
  console.log(`Skills: ${results.skills.length}`);
  console.log(`跳过: ${results.skipped.length}`);

  return results;
}

crystallize();
