const fs = require('fs');
const path = require('path');

class CreateHook {
  constructor(config) {
    this.config = config;
    this.hooksDir = path.join(process.env.HOME, '.openclaw', 'foundry', 'hooks');
  }

  async create(options) {
    const { name, type = 'recovery', tool, trigger, action } = options;
    const hookFile = path.join(this.hooksDir, `${name}.ts`);

    if (fs.existsSync(hookFile)) {
      return { success: false, error: `Hook ${name} already exists` };
    }

    const content = this.generateHook(name, type, tool, trigger, action);
    fs.writeFileSync(hookFile, content);

    return { success: true, path: hookFile };
  }

  generateHook(name, type, tool, trigger, action) {
    const templates = {
      'recovery': this.generateRecoveryHook(name, tool, trigger, action),
      'enhancement': this.generateEnhancementHook(name, tool, trigger, action),
      'monitoring': this.generateMonitoringHook(name, tool, trigger, action),
      'fallback': this.generateFallbackHook(name, tool, trigger, action)
    };

    return templates[type] || templates['recovery'];
  }

  generateRecoveryHook(name, tool, trigger, action) {
    return `// Auto-generated by meta-improver
// Type: recovery
// Tool: ${tool}
// Generated: ${new Date().toISOString()}

export default async function ${this.toCamelCase(name)}(context: any) {
  const { toolResult, attempt, maxAttempts = 3 } = context;
  
  if (!toolResult?.success && attempt < maxAttempts) {
    const recovery = {
      shouldRetry: true,
      delay: Math.min(1000 * Math.pow(2, attempt), 30000),
      ${action ? `action: '${action}'` : ''}
    };
    
    return recovery;
  }
  
  return { shouldRetry: false };
}
`;
  }

  generateEnhancementHook(name, tool, trigger, action) {
    return `// Auto-generated by meta-improver
// Type: enhancement
// Tool: ${tool}
// Generated: ${new Date().toISOString()}

export default async function ${this.toCamelCase(name)}(context: any) {
  const { toolResult, input } = context;
  
  if (toolResult?.success) {
    const enhancement = {
      enhanced: true,
      ${action ? `action: '${action}'` : ''}
    };
    
    return enhancement;
  }
  
  return { enhanced: false };
}
`;
  }

  generateMonitoringHook(name, tool, trigger, action) {
    return `// Auto-generated by meta-improver
// Type: monitoring
// Tool: ${tool}
// Generated: ${new Date().toISOString()}

interface MonitorResult {
  monitored: boolean;
  metrics?: {
    duration: number;
    success: boolean;
    timestamp: string;
  };
}

export default async function ${this.toCamelCase(name)}(context: any): Promise<MonitorResult> {
  const startTime = Date.now();
  const { toolResult } = context;
  
  return {
    monitored: true,
    metrics: {
      duration: Date.now() - startTime,
      success: toolResult?.success || false,
      timestamp: new Date().toISOString()
    }
  };
}
`;
  }

  generateFallbackHook(name, tool, trigger, action) {
    return `// Auto-generated by meta-improver
// Type: fallback
// Tool: ${tool}
// Generated: ${new Date().toISOString()}

export default async function ${this.toCamelCase(name)}(context: any) {
  const { toolResult, input } = context;
  
  if (!toolResult?.success) {
    return {
      fallback: true,
      ${action ? `alternativeAction: '${action}'` : ''}
      reason: 'Primary tool failed'
    };
  }
  
  return { fallback: false };
}
`;
  }

  toCamelCase(str) {
    return str.split('-').map((word, i) => 
      i === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
    ).join('');
  }
}

module.exports = { CreateHook };
